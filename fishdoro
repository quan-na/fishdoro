#!/usr/bin/env fish

set fr_num_todos 10
set fr_root '.'
set fr_ch_est 'ü§î'
set fr_ch_pomo 'üçÖ'
set fr_ch_good 'üòÄ'
set fr_ch_bad 'üò•'
set fr_pomo_len 2 # 25
set fr_brk_shrt 2 # 5
set fr_brk_long 2 # 15

function fr_usage
    echo "Sample usages:"
    echo " fishdoro list"
    echo " : List activity inventory"
    echo " fishdoro add A sample activity description"
    echo " : Add an activity named 'A sample activity description' with estimation of 1 pomodoro"
    echo " fishdoro add A sample activity description 5"
    echo " : Add an activity named 'A sample activity description' with estimation of 5 pomodoros"
    echo " fishdoro tour"
    echo " : Start activity tournament"
    echo " fishdoro pomo 5"
    echo " : Start pomodoro on 5th activity"
    echo " fishdoro break"
    echo " : Start a break"
    echo " fishdoro break long"
    echo " : Start a long break"
    echo " fishdoro finish"
    echo " : Finish last activity"
    echo " fishdoro trash"
    echo " : Trash current pomodoro"
end

function fr_ai_list
    set cnt (wc -l < $fr_root/inventory.txt)
    for line in (cat $fr_root/inventory.txt)
        if [ ! $fr_num_todos -lt $cnt ]
            echo "[$cnt] $line"
        else
            echo "\($cnt\) $line"
        end
        set cnt (math "$cnt - 1")
    end
end

function fr_ai_add # original $argv
    if [ 3 -gt (count $argv) ]
        fr_usage
    else
        switch (math "$argv[-1]")
            case 0;
                set act_str $argv[2..-1] $fr_ch_est
            case '*';
                set act_str $argv[2..-2] (printf "%0.*d" $argv[-1] 0 | string replace -a 0 $fr_ch_est)
        end
        flock $fr_root/inventory.txt -c "echo $act_str >> $fr_root/inventory.txt"
        echo Activity added : $act_str
    end
end

function fr_ai_tour
    begin
        flock -e 200
        set array (cat $fr_root/inventory.txt)
        set arrLen (count $array)

        for sorted in (seq 1 $fr_num_todos)
            for idx in (seq 1 (math "$arrLen - $sorted"))
                set idx1 (math "$idx + 1")
                echo ""
                echo "[J]ack :: $array[$idx]"
                echo "         -----VS-----"
                echo "[K]ing :: $array[$idx1]"
                echo -n "Which is chosen?(j/k/e)"
                read -P ' ' -n1 ans
                while [ $ans != 'j' -a $ans != k -a $ans != 'J' -a $ans != 'K' -a $ans != 'e' -a $ans != 'E' ]
                    read -P ' ' -n1 ans
                end
                if [ $ans = 'e' -o $ans = 'E' ]
                    exit 0
                end
                if [ $ans = 'j' -o $ans = 'J' ]
                    if [ $idx -eq 1 ]
                        if [ $idx1 -eq $arrLen ]
                            set array $array[$idx1] $array[$idx]
                        else
                            set idx2 (math "$idx1 + 1")
                            set array $array[$idx1] $array[$idx] $array[$idx2..$arrLen]
                        end
                    else if [ $idx1 -eq $arrLen ]
                        set idx0 (math "$idx - 1")
                        set array $array[1..$idx0] $array[$idx1] $array[$idx]
                    else
                        set idx2 (math "$idx1 + 1")
                        set idx0 (math "$idx - 1")
                        set array $array[1..$idx0] $array[$idx1] $array[$idx] $array[$idx2..$arrLen]
                    end
                end
            end
        end

        truncate -s 0 $fr_root/inventory.txt
        echo ''
        echo Result:
        for idx in (seq 1 $arrLen)
            echo $array[$idx] >> $fr_root/inventory.txt
            echo "["(math "$arrLen - $idx + 1")"]" $array[$idx]
        end
    end 200<$fr_root/inventory.txt
end

function fr_pomo
    if [ 2 -gt (count $argv) ]
        fr_usage
        exit 1
    end
    set curr (math "$argv[2]")
    begin
        flock -e 200
        if cat $fr_root/inventory.txt | grep $fr_ch_pomo >> /dev/null
            echo A pomodoro is already running!
            exit 1
        end
        set array (cat $fr_root/inventory.txt)
        set arrLen (count $array)

        truncate -s 0 $fr_root/inventory.txt
        for idx in (seq 1 $arrLen)
            if [ $curr -eq (math "$arrLen - $idx + 1") ]
                echo $array[$idx] $fr_ch_pomo >> $fr_root/inventory.txt
            else
                echo $array[$idx] >> $fr_root/inventory.txt
            end
        end
    end 200<$fr_root/inventory.txt

    # TODO end pomodoro
    for time in (seq 1 $fr_pomo_len)
        set remain (math "$fr_pomo_len - $time + 1")
        if [ $remain -gt 1 ]
            echo $remain minutes remains
            sleep 60
        else
            break
        end
    end
    for time in (seq 1 60)
        set remain (math "60 - $time")
        sleep 1
        echo $remain seconds remains
    end
    begin
        flock -e 200
        set array (cat $fr_root/inventory.txt)
        set arrLen (count $array)

        truncate -s 0 $fr_root/inventory.txt
        for idx in (seq 1 $arrLen)
            set line $array[$idx]
            if string match "* $fr_ch_pomo" "$line" > /dev/null
                set line (string replace " $fr_ch_pomo" '' $line) # remove the pomo char
                if string match "*$fr_ch_est*" $line[-1] > /dev/null
                    echo (string replace $fr_ch_est $fr_ch_good $line) >> $fr_root/inventory.txt
                else
                    echo $line$fr_ch_bad >> $fr_root/inventory.txt
                end
            else
                echo $line >> $fr_root/inventory.txt
            end
        end
    end 200<$fr_root/inventory.txt
    echo Pomo ended
end

function fr_break
    echo 'break $argv'
end

function fr_finish
    echo 'finish activity'
end

function fr_trash
    echo 'trash current pomodoro'
end

switch "$argv[1]"
    case 'list'; fr_ai_list
    case 'add'; fr_ai_add $argv
    case 'tour'; fr_ai_tour
    case 'pomo'; fr_pomo $argv
    case 'break'; fr_break "$argv[2]"
    case 'finish'; fr_finish "$argv[2]"
    case 'trash'; fr_trash
    case 'help'
        fr_usage
    case '*';
        fr_usage
        exit 1
end

exit 0
